"""
System Logging module.

This module provides the LOG pseudo function quickly creating a logger instance
for use.

The default log level can also be programatically be changed by setting the
LOG.level parameter.
"""

import inspect
import queue
import logging
import os
import sys
import core
from logging import DEBUG, INFO


def _make_log_method(fn):
    @classmethod
    def method(cls, *args, **kwargs):
        cls._log(fn, *args, **kwargs)

    method.__func__.__doc__ = fn.__doc__
    return method


class LOG:
    """
    Custom logger class that acts like logging.Logger
    The logger name is automatically generated by the module of the caller

    Usage:
        >>> LOG.debug('My message: %s', debug_str)
        13:12:43.673 - :<module>:1 - DEBUG - My message: hi
        >>> LOG('custom_name').debug('Another message')
        13:13:10.462 - custom_name - DEBUG - Another message
    """

    _custom_name = None
    handler = None
    level = logging.getLevelName("INFO")

    # Copy actual logging methods from logging.Logger
    # Usage: LOG.debug(message)
    debug = _make_log_method(logging.Logger.debug)
    info = _make_log_method(logging.Logger.info)
    warning = _make_log_method(logging.Logger.warning)
    error = _make_log_method(logging.Logger.error)
    exception = _make_log_method(logging.Logger.exception)

    @classmethod
    def init(cls):
        """Initializes the class, sets the default log level and creates
        the required handlers.
        """
        app_config = core.Configuration.get()
        log_message_format = (
            "{asctime} |  {process:5} | {levelname:8} | {name} | {message} "
        )

        formatter = logging.Formatter(log_message_format, style="{")
        formatter.default_msec_format = "%s.%03d"

        if app_config.get("log_dir"):
            if not os.path.exists(app_config.get("log_dir")):
                os.makedirs(app_config.get("log_dir"))
            log_file_path = os.path.join(app_config.get("log_dir"), "dev.log")
            cls.handler = logging.FileHandler(log_file_path)
        else:
            cls.handler = logging.FileHandler("dev.log")

        if app_config.get("log_format"):
            formatter = logging.Formatter(app_config.get("log_format"), style="{")
            cls.handler.setFormatter(formatter)

        cls.handler.setFormatter(formatter)
        cls.level = logging.getLevelName(app_config.get("log_level", "INFO"))

        # Enable logging in external modules
        cls.create_logger("").setLevel(cls.level)

    @classmethod
    def create_logger(cls, name):
        logger = logging.getLogger(name)
        logger.propagate = False
        logger.addHandler(cls.handler)
        return logger

    def __init__(self, name):
        LOG._custom_name = name

    @classmethod
    def _log(cls, func, *args, **kwargs):
        if cls._custom_name is not None:
            name = cls._custom_name
            cls._custom_name = None
        else:
            # Stack:
            # [0] - _log()
            # [1] - debug(), info(), warning(), or error()
            # [2] - caller
            try:
                stack = inspect.stack()

                # Record:
                # [0] - frame object
                # [1] - filename
                # [2] - line number
                # [3] - function
                # ...
                record = stack[2]
                mod = inspect.getmodule(record[0])
                module_name = mod.__name__ if mod else ""
                name = module_name + ":" + record[3] + ":" + str(record[2])
            except Exception:
                # The location couldn't be determined
                name = "core"

        func(cls.create_logger(name), *args, **kwargs)
